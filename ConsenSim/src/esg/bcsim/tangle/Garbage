
    
    
    package esg.bcsim.tangle;

import java.util.Random;
import java.util.concurrent.CountDownLatch;

public class TangleTipFinderOLD extends Thread {
	   private Thread t;
	   private String threadName;
	   private CountDownLatch countdown;
	   private Tanglev2 tangle;
	   
	   private int tip = -1;
	   private int startTx;
	   private Random rand;
	   
	   public int getTip() {
		   return(tip);
	   }
	   
	   TangleTipFinderOLD(String name, int particle, 
			   CountDownLatch countDownLatch, 
			   Tanglev2 t) {
	      threadName = name;
	      startTx = particle;
	      countdown = countDownLatch;
	      tangle = t;
	   }
	   
	   
	   private void findTip(int currPart) {
		   out(threadName + ": Moving a step with particle: " + currPart);
		   if (tangle.isTip(currPart)) {
			   tip = currPart;
			   out(threadName + ": Particle " + currPart + " is tip.");
		   } else {
			   out(threadName + ": Particle " + currPart + " is NOT a tip. Moving on.");
			   findTip(tangle.takeOneMCMCStep(currPart));
		   }
	   }
	   
	   public void run() {
		   startTx = findStartingTx();
		   findTip(startTx);
		   countdown.countDown(); 
	   }
	   
	   private int findStartingTx() {
		   int i;
		   do {
			   i = rand.nextInt(tangle.maxTransaction + 1);
		   } while ((tangle.tangle[i][0] < tangle.maxWeight*TangleParameters.WminPercentile) ||  (tangle.tangle[i][0] > tangle.maxWeight*TangleParameters.WminPercentile));
		   
		   return i;
	   }

	   public void start () {
		   //System.out.println("Starting " +  threadName );
		   if (t == null) {
			   t = new Thread (this, threadName);
			   t.start ();
		   }
	   }

	    //
	    //
	    // H E L P E R S
	    //
	    //
	    
		private void hold(int ms) {
			try {
				Thread.sleep(ms);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}
		
		private void out(String s) {
			System.out.println(s);
			//hold(5000);
		}

		private void outnl(String s) {
			System.out.print(s);
		}
	    
	   
	   
}
    	private ArrayList<Integer> getParticles() {
		ArrayList<Integer> chosenOnes = new ArrayList<Integer>();
		int i;
		
		i = Math.round(maxWeight*TangleParameters.WminPercentile);
		outnl("Getting cutset from:" + i + " to: " + (Math.round(maxWeight*TangleParameters.WmaxPercentile) - 1));
		out(" (maxWeight = " + maxWeight + ")");
		
		do {
			if (tangle[i][0] > 0 ) {
				chosenOnes.add(i);
			}
			i++;
		} while (i < Math.round(maxWeight*TangleParameters.WmaxPercentile));
		
		Collections.shuffle(chosenOnes);
		
		out("Particles found:" + chosenOnes);
		return(chosenOnes);
	}
    
    
    
    
    // GARBAGE
    
    
	private int[] findParents() {
		int[] p  = new int[2];
		int stepResult,currPart;
		ArrayList<Integer> tips = new ArrayList<Integer>();
		Set<Integer> tipSet = new HashSet<Integer>();
		
		
		long temp = System.currentTimeMillis();
		ArrayList<Integer>  parts = getParticles();
		totalgetingParticles += (System.currentTimeMillis() - temp);
		
		//TODO: put the parameter here.
		Queue<Integer> partQueue = new LinkedList<Integer>(parts.stream().limit(TangleParameters.NumofParticles).collect(Collectors.toList()));
		
		
		noParticles = partQueue.size();
		
		
		out("Initial Particle Queue:" + parts);
		hold(3000);
		
		
		temp = System.currentTimeMillis();
		while ((!partQueue.isEmpty()) && tipSet.size()<2) {
			currPart = partQueue.poll();
			outnl("Popping queue: " + currPart + " ");
			if (isTip[currPart]) {
				out("Is tip. Adding to tips.");
				tips.add(currPart);
			} else {
				stepResult = takeOneMCMCStep(currPart);
				outnl("Not a tip. Moved it and got " + stepResult + ". " );
				if (isTip[stepResult]) {
					//out(" Which is a tip so I add it to the tips. ");
					tips.add(stepResult);
				} else {
					//out(" Which is not a tip so I push it back to the queue.");
					partQueue.add(stepResult);
				}
			}
		
			out("Tips: " + tips);
			out("Queue: " + partQueue);
			hold(5000);
			tipSet = new HashSet<Integer>(tips);
		}
		totalgetTips += (System.currentTimeMillis() - temp);    
		
		out("Loop ends. Resulting tipset: " + tipSet);
		hold(5000);
		
		
		if (tipSet.size()>=2) {
			out(tipSet.toString());
	    	p = tipSet.stream().mapToInt(i->i).toArray();
	    	out("Found tips: " + p[0] + " AND " + p[1]);

	    } else if (tipSet.size()==1) {
	    	outnl("Problem, only one tip: " + tips.get(0) + ". ");
	    	p[0] = tips.get(0);
	    	// Pick a random transaction for the other tip.
	    	int randPick;
	    	do {
	    		randPick = rand.nextInt(maxTransaction);
	    	} while ((tangle[randPick][0] == 0)||(randPick == p[0])); // transaction exists
	    	
	    	out("Picking randomly: " + randPick);
	    	p[1] = randPick;
	    } else {
	    	out("Problem, no tips!");
	    	p[0] = -1;
	    	p[1] = -1;
	    }
	    hold(5000);
		return(p);
	}
	
    
    
    
	private ArrayList<Integer> findChildrenOLD(int t) {
		ArrayList<Integer> children = new ArrayList<Integer>(); 
		for (int i = t; i <= maxTransaction; i++) {
			if ((tangle[i][1] == t) || (tangle[i][2] == t)) {
				children.add(i);
			}
		}
		return (children);
	}
    
    

	private int getTipfromParticle(int t) {
		ArrayList<Integer> children;
		children  = findChildren(t);
		int tip = -1;
		
		//System.out.println("Children for:" + t + " are " + children);
		
		if (children.isEmpty()) {
			tip = t;
			//System.out.println("Tip:" + t + " found.");	
		} else {
			//pick a random child
			int index;
			if (children.size()>1)
				index = rand.nextInt(children.size() - 1);
			else
				index = 0;
			//try to get a tip from that
			tip = getTipfromParticle(children.get(index));
		}
		return(tip);
	}

    
	
	private int[] findTwoParents(int Tx) {

		int[] parents = new int[2];
		
		do {
			parents[0] = rand.nextInt((maxTransaction - 0) + 1) + 0;	
		} while ((tangle[parents[0]][0] <= 0) && isTip[parents[0]] && (parents[0] == Tx)); // transaction has not occurred yet
		

		do {
			parents[1] = rand.nextInt((maxTransaction - 0) + 1) + 0;	
		} while ((tangle[parents[1]][0] <= 0) && isTip[parents[1]] && (parents[1] == Tx)); // transaction has not occurred yet
		
		
		return parents;
		
//		ArrayList<Integer> tips = new ArrayList<Integer>();
//		ArrayList<Integer>  parts = getParticles(TangleParameters.NumofParticles);
//		for (int p : parts) {
//			tips.add(getTipfromParticle(p));
//		}
//		
	}
	private int[] findParentsOld() {
		int[] p  = new int[2];
		ArrayList<Integer> tips = new ArrayList<Integer>();
		
		
		ArrayList<Integer>  parts = getParticles();
		
	     for (int counter = 0; (counter < TangleParameters.NumofParticles) && counter < parts.size(); counter++) { 		      
	    	 tips.add(getTipfromParticle(parts.get(counter)));	
	      }
	    Collections.shuffle(tips);
	    
	    
	    if (tips.size()>=2) {
	    	p[0] = tips.get(0);
	    	p[1] = tips.get(1);
	    	System.out.println("All tips found: " + tips);
	    	System.out.println("Found tips: " + p[0] + " AND " + p[1]);
	    	boolean found = false;
	    	if (p[0]==p[1]) {
	    	    for (int counter = 2; (counter < tips.size()) && !found; counter++) { 		      
	    	    	p[1] = tips.get(counter);
	    	    	if (p[0]!=p[1]) found = true;
	    	    }   	
	    	}
	    } else if (tips.size()==1) {
	    	System.out.println("Problem, only one tip");
	    	p[0] = tips.get(0);
	    	p[1] = tips.get(0);
	    } else {
	    	System.out.println("Problem, no tips!");
	    	p[0] = -1;
	    	p[1] = -1;
	    }
	    
		return(p);
	}
	
	
